#!/bin/bash
# Generate SLO Report
# Part of WS-018-04: SLI/SLO Definitions & Monitoring

set -e

# Configuration
PROMETHEUS_URL="${PROMETHEUS_URL:-http://localhost:9090}"
REPORT_MONTH="${1:-$(date +'%Y-%m')}"
REPORT_FILE="slo-report-${REPORT_MONTH}.md"

echo "üìä Generating SLO Report for ${REPORT_MONTH}..."

# Query Prometheus function
query_prometheus() {
    local query="$1"
    curl -s -G "${PROMETHEUS_URL}/api/v1/query" \
        --data-urlencode "query=${query}" | \
        jq -r '.data.result[0].value[1] // "0"'
}

# Get metrics
AVAILABILITY=$(query_prometheus "slo_availability_30d * 100")
JOB_SUCCESS=$(query_prometheus "slo_job_success_rate_7d")
LATENCY_P95=$(query_prometheus "slo_latency_p95_24h")
THROUGHPUT=$(query_prometheus "slo_throughput_1h")
BURN_RATE=$(query_prometheus "error_budget_burn_rate")
BUDGET_REMAINING=$(query_prometheus "error_budget_remaining")

# Calculate downtime from availability
AVAILABILITY_DECIMAL=$(echo "scale=4; $AVAILABILITY / 100" | bc)
TOTAL_MINUTES=43200  # 30 days
DOWNTIME=$(echo "scale=1; $TOTAL_MINUTES * (1 - $AVAILABILITY_DECIMAL)" | bc)

# Generate report
cat > "$REPORT_FILE" << EOF
# SLO Report: ${REPORT_MONTH}

**Generated:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")

---

## Executive Summary

| SLO | Target | Actual | Met? | Budget Burn |
|-----|--------|--------|------|-------------|
| Availability | 99.9% | ${AVAILABILITY}% | $(echo "$AVAILABILITY >= 99.9" | bc -l | awk '{if($1==1) print "‚úÖ Yes"; else print "‚ùå No"}') | ${DOWNTIME} minutes |
| Job Success Rate | 99% | ${JOB_SUCCESS}% | $(echo "$JOB_SUCCESS >= 99" | bc -l | awk '{if($1==1) print "‚úÖ Yes"; else print "‚ùå No"}') | $(echo "scale=1; 100 - $JOB_SUCCESS" | bc)% |
| Latency (p95) | <5s | ${LATENCY_P95}s | $(echo "$LATENCY_P95 < 5" | bc -l | awk '{if($1==1) print "‚úÖ Yes"; else print "‚ùå No"}') | N/A |
| Throughput | 100 jobs/h | ${THROUGHPUT} jobs/h | $(echo "$THROUGHPUT >= 100" | bc -l | awk '{if($1==1) print "‚úÖ Yes"; else print "‚ùå No"}') | N/A |

---

## Availability

**Target:** 99.9% (43.2 minutes/month)
**Actual:** ${AVAILABILITY}%
**Downtime:** ${DOWNTIME} minutes

### Error Budget Status

- **Starting budget:** 43.2 minutes
- **Consumed:** ${DOWNTIME} minutes
- **Remaining:** $(echo "scale=1; 43.2 - $DOWNTIME" | bc) minutes (${BUDGET_REMAINING}%)
- **Burn rate:** ${BURN_RATE}x of allocation

**Burn Rate Interpretation:**
$(echo "$BURN_RATE < 1" | bc -l | awk '{if($1==1) print "‚úÖ Consuming budget slower than allocation"; else print ""}')
$(echo "$BURN_RATE >= 1 && $BURN_RATE <= 2" | bc -l | awk '{if($1==1) print "‚ö†Ô∏è  Consuming budget as expected - Monitor closely"; else print ""}')
$(echo "$BURN_RATE > 2 && $BURN_RATE <= 10" | bc -l | awk '{if($1==1) print "üö® Consuming budget too fast - Stop releases"; else print ""}')
$(echo "$BURN_RATE > 10" | bc -l | awk '{if($1==1) print "üî¥ Burning budget rapidly - Emergency"; else print ""}')

---

## Job Success Rate

**Target:** 99% (‚â§1% failures)
**Actual:** ${JOB_SUCCESS}%

### Monthly Job Statistics

- **Total jobs:** $(query_prometheus "sum(increase(spark_job_completed_total[30d]))")
- **Successful:** $(query_prometheus "sum(increase(spark_job_completed_total{status=\"success\"}[30d]))")
- **Failed:** $(query_prometheus "sum(increase(spark_job_failed_total[30d]))")

---

## Performance

### Latency

**Target:** p95 < 5s
**Actual:** ${LATENCY_P95}s

### Throughput

**Target:** 100 jobs/hour
**Actual:** ${THROUGHPUT} jobs/hour

---

## Incidents This Month

<!-- Manually update this section based on incident tickets -->

| Date | Severity | Incident | Downtime/Impact |

---

## Actions Taken

<!-- List improvements made this month -->

- [ ]
- [ ]

---

## Next Month Goals

<!-- Set goals for next month -->

- [ ]
- [ ]

---

**Report Generated By:** spark-k8s slo-report.sh
**Data Source:** ${PROMETHEUS_URL}
EOF

echo "‚úÖ SLO Report generated: $REPORT_FILE"
echo ""
echo "Next steps:"
echo "  1. Review the report: cat $REPORT_FILE"
echo "  2. Fill in incidents and actions sections"
echo "  3. Share with stakeholders"
echo "  4. Archive report for historical tracking"
