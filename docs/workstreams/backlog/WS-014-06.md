---
ws_id: WS-014-06
feature: F14
status: backlog
size: MEDIUM
project_id: 014
github_issue: null
assignee: null
depends_on: []
---

## WS-014-06: Container security (8 scenarios)

### ðŸŽ¯ Goal

**What must WORK after completing this WS:**
- 8 container security test scenarios for pod hardening
- Tests cover non-root user, privilege escalation, read-only filesystem, and capabilities
- Tests validate container security context across all Spark components

**Acceptance Criteria:**
- [ ] AC1: 4 test files created in tests/security/container/
- [ ] AC2: test_container_non_root.py validates non-root user
- [ ] AC3: test_container_no_privilege.py validates privilege escalation disabled
- [ ] AC4: test_container_readonly_fs.py validates read-only root filesystem
- [ ] AC5: test_container_capabilities.py validates dropped capabilities
- [ ] AC6: All tests validate both Spark 3.5 and 4.1 charts
- [ ] AC7: Coverage >= 80% for all container security test files
- [ ] AC8: All tests pass with pytest

**âš ï¸ WS is NOT complete until Goal is achieved (all AC âœ…).**

---

### Context

Container security hardening is critical for running workloads securely. This WS creates tests to validate that our Helm charts configure containers with secure defaults: non-root user, no privilege escalation, read-only filesystem (where possible), and dropped capabilities.

**Test Matrix (8 scenarios):**
- Non-root user validation (runAsUser != 0)
- No privilege escalation (allowPrivilegeEscalation: false)
- Read-only root filesystem (readOnlyRootFilesystem: true)
- Drop capabilities (CAP_NET_RAW, etc.)
- Security context at pod level
- Security context at container level
- seccomp profile (RuntimeDefault or Localhost)
- AppArmor profile (if applicable)

### Dependencies

- Phase 0: Security context templates
- Phase 1: Security context configuration in values

### Input Files

- charts/spark-3.5/values.yaml (security context configuration)
- charts/spark-4.1/values.yaml (security context configuration)
- charts/spark-3.5/presets/core-baseline.yaml

### Steps

1. **Create tests/security/container/test_container_non_root.py**

   Write tests for non-root user validation:
   - Test that pod security context sets runAsUser != 0
   - Test that container security context sets runAsUser != 0
   - Test that runAsGroup is set (if applicable)
   - Test that fsGroup is set for volume permissions

2. **Create tests/security/container/test_container_no_privilege.py**

   Write tests for privilege escalation validation:
   - Test that allowPrivilegeEscalation is false
   - Test that privileged is false (or not set)
   - Test that no container has privileged: true
   - Test that capabilities are dropped

3. **Create tests/security/container/test_container_readonly_fs.py**

   Write tests for read-only root filesystem:
   - Test that readOnlyRootFilesystem is true (or configurable)
   - Test that tmpfs is used for writable directories
   - Test that volume mounts work with read-only root

4. **Create tests/security/container/test_container_capabilities.py**

   Write tests for dropped capabilities:
   - Test that drop capabilities are set
   - Test that CAP_NET_RAW is dropped (no raw sockets)
   - Test that add capabilities are minimal (only if required)
   - Test that no wildcard capabilities ("ALL") are added

### Code

```python
# tests/security/container/test_container_non_root.py
"""Container security tests for non-root user validation"""

import pytest
import subprocess
import yaml
from pathlib import Path
from typing import List, Dict, Any


class TestContainerNonRoot:
    """Tests for non-root user validation"""

    @pytest.fixture(scope="class")
    def chart_path(self):
        return Path(__file__).parent.parent.parent.parent / "charts" / "spark-3.5"

    @pytest.fixture(scope="class")
    def preset_path(self, chart_path):
        return chart_path / "presets" / "core-baseline.yaml"

    def _get_pod_specs(self, chart_path: Path, preset_path: Path) -> List[Dict[str, Any]]:
        """Helper to get all pod specs from rendered chart"""
        result = subprocess.run(
            ["helm", "template", "test", str(chart_path), "-f", str(preset_path)],
            capture_output=True, text=True
        )
        assert result.returncode == 0, "helm template should succeed"

        docs = list(yaml.safe_load_all(result.stdout))
        pod_specs = []

        for doc in docs:
            if not doc:
                continue
            kind = doc.get("kind", "")
            if kind in ["Deployment", "StatefulSet", "DaemonSet", "Job", "Pod"]:
                template = doc.get("spec", {}).get("template", {})
                spec = template.get("spec", {})
                pod_specs.append({
                    "kind": kind,
                    "name": doc.get("metadata", {}).get("name", "unknown"),
                    "spec": spec
                })

        return pod_specs

    def test_pod_run_as_user_is_not_root(self, chart_path, preset_path):
        """Test that pod security context sets runAsUser != 0"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            pod_sec_ctx = pod_spec["spec"].get("securityContext", {})
            run_as_user = pod_sec_ctx.get("runAsUser")

            # If runAsUser is set, it should not be root (0)
            if run_as_user is not None:
                assert run_as_user != 0, \
                    f"{pod_spec['kind']}/{pod_spec['name']} should not run as root user (0), got {run_as_user}"

    def test_container_run_as_user_is_not_root(self, chart_path, preset_path):
        """Test that container security context sets runAsUser != 0"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                run_as_user = sec_ctx.get("runAsUser")

                # If runAsUser is set, it should not be root (0)
                if run_as_user is not None:
                    assert run_as_user != 0, \
                        f"Container {container_name} in {pod_spec['kind']}/{pod_spec['name']} " \
                        f"should not run as root user (0), got {run_as_user}"

    def test_run_as_group_is_set(self, chart_path, preset_path):
        """Test that runAsGroup is set (if applicable)"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            pod_sec_ctx = pod_spec["spec"].get("securityContext", {})
            run_as_group = pod_sec_ctx.get("runAsGroup")

            # If runAsUser is set, runAsGroup should also be set for consistency
            run_as_user = pod_sec_ctx.get("runAsUser")
            if run_as_user is not None and run_as_group is None:
                # This is a warning, not a failure
                pytest.skip(f"runAsGroup not set for {pod_spec['kind']}/{pod_spec['name']} " \
                          f"(runAsUser={run_as_user})")

    def test_fs_group_is_set(self, chart_path, preset_path):
        """Test that fsGroup is set for volume permissions"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            pod_sec_ctx = pod_spec["spec"].get("securityContext", {})
            volumes = pod_spec["spec"].get("volumes", [])

            # If volumes are defined, fsGroup should be set
            if len(volumes) > 0:
                fs_group = pod_sec_ctx.get("fsGroup")
                # fsGroup should be set when volumes are present
                # (for proper file permissions)
                if fs_group is None:
                    pytest.skip(f"fsGroup not set for {pod_spec['kind']}/{pod_spec['name']} " \
                              f"(has {len(volumes)} volumes)")
```

```python
# tests/security/container/test_container_no_privilege.py
"""Container security tests for privilege escalation validation"""

import pytest
import subprocess
import yaml
from pathlib import Path
from typing import List, Dict, Any


class TestContainerNoPrivilege:
    """Tests for privilege escalation validation"""

    @pytest.fixture(scope="class")
    def chart_path(self):
        return Path(__file__).parent.parent.parent.parent / "charts" / "spark-3.5"

    @pytest.fixture(scope="class")
    def preset_path(self, chart_path):
        return chart_path / "presets" / "core-baseline.yaml"

    def _get_pod_specs(self, chart_path: Path, preset_path: Path) -> List[Dict[str, Any]]:
        """Helper to get all pod specs from rendered chart"""
        result = subprocess.run(
            ["helm", "template", "test", str(chart_path), "-f", str(preset_path)],
            capture_output=True, text=True
        )
        assert result.returncode == 0

        docs = list(yaml.safe_load_all(result.stdout))
        pod_specs = []

        for doc in docs:
            if not doc:
                continue
            kind = doc.get("kind", "")
            if kind in ["Deployment", "StatefulSet", "DaemonSet", "Job", "Pod"]:
                template = doc.get("spec", {}).get("template", {})
                spec = template.get("spec", {})
                pod_specs.append({
                    "kind": kind,
                    "name": doc.get("metadata", {}).get("name", "unknown"),
                    "spec": spec
                })

        return pod_specs

    def test_allow_privilege_escalation_is_false(self, chart_path, preset_path):
        """Test that allowPrivilegeEscalation is false"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                allow_priv = sec_ctx.get("allowPrivilegeEscalation")

                # If set, it should be false
                if allow_priv is not None:
                    assert allow_priv is False, \
                        f"Container {container_name} in {pod_spec['kind']}/{pod_spec['name']} " \
                        f"should have allowPrivilegeEscalation=false, got {allow_priv}"

    def test_no_container_has_privileged_true(self, chart_path, preset_path):
        """Test that no container has privileged: true"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                privileged = sec_ctx.get("privileged")

                # privileged should never be true
                assert privileged is not True, \
                    f"Container {container_name} in {pod_spec['kind']}/{pod_spec['name']} " \
                    f"should not have privileged=true"

    def test_capabilities_are_dropped(self, chart_path, preset_path):
        """Test that capabilities are dropped"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                capabilities = sec_ctx.get("capabilities", {})

                drop = capabilities.get("drop", [])
                # Check that at least some capabilities are dropped
                if len(drop) > 0:
                    # Good - capabilities are being dropped
                    assert isinstance(drop, list), "drop capabilities should be a list"
```

```python
# tests/security/container/test_container_readonly_fs.py
"""Container security tests for read-only root filesystem"""

import pytest
import subprocess
import yaml
from pathlib import Path
from typing import List, Dict, Any


class TestContainerReadOnlyFS:
    """Tests for read-only root filesystem validation"""

    @pytest.fixture(scope="class")
    def chart_path(self):
        return Path(__file__).parent.parent.parent.parent / "charts" / "spark-3.5"

    @pytest.fixture(scope="class")
    def preset_path(self, chart_path):
        return chart_path / "presets" / "core-baseline.yaml"

    def _get_pod_specs(self, chart_path: Path, preset_path: Path) -> List[Dict[str, Any]]:
        """Helper to get all pod specs from rendered chart"""
        result = subprocess.run(
            ["helm", "template", "test", str(chart_path), "-f", str(preset_path)],
            capture_output=True, text=True
        )
        assert result.returncode == 0

        docs = list(yaml.safe_load_all(result.stdout))
        pod_specs = []

        for doc in docs:
            if not doc:
                continue
            kind = doc.get("kind", "")
            if kind in ["Deployment", "StatefulSet", "DaemonSet", "Job", "Pod"]:
                template = doc.get("spec", {}).get("template", {})
                spec = template.get("spec", {})
                pod_specs.append({
                    "kind": kind,
                    "name": doc.get("metadata", {}).get("name", "unknown"),
                    "spec": spec
                })

        return pod_specs

    def test_readonly_root_filesystem_is_configured(self, chart_path, preset_path):
        """Test that readOnlyRootFilesystem is true (or configurable)"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                readonly_fs = sec_ctx.get("readOnlyRootFilesystem")

                # If set, it should ideally be true
                # (but we allow false for writable workloads)
                if readonly_fs is not None:
                    assert isinstance(readonly_fs, bool), \
                        f"readOnlyRootFilesystem should be boolean for {container_name}"

    def test_tmpfs_used_for_writable_directories(self, chart_path, preset_path):
        """Test that tmpfs is used for writable directories"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            volumes = pod_spec["spec"].get("volumes", [])
            for volume in volumes:
                if volume.get("name", "").endswith("-tmp"):
                    # Check if tmpfs is used for temporary volumes
                    assert "emptyDir" in volume or "configMap" in volume or "secret" in volume, \
                        f"Temporary volume {volume['name']} should use emptyDir or tmpfs"

    def test_volume_mounts_work_with_readonly_root(self, chart_path, preset_path):
        """Test that volume mounts work with read-only root"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                volume_mounts = container.get("volumeMounts", [])
                # If readOnlyRootFilesystem is true, volume mounts should have readWrite flag
                # for directories that need to be writable
```

```python
# tests/security/container/test_container_capabilities.py
"""Container security tests for dropped capabilities"""

import pytest
import subprocess
import yaml
from pathlib import Path
from typing import List, Dict, Any


class TestContainerCapabilities:
    """Tests for dropped capabilities validation"""

    @pytest.fixture(scope="class")
    def chart_path(self):
        return Path(__file__).parent.parent.parent.parent / "charts" / "spark-3.5"

    @pytest.fixture(scope="class")
    def preset_path(self, chart_path):
        return chart_path / "presets" / "core-baseline.yaml"

    def _get_pod_specs(self, chart_path: Path, preset_path: Path) -> List[Dict[str, Any]]:
        """Helper to get all pod specs from rendered chart"""
        result = subprocess.run(
            ["helm", "template", "test", str(chart_path), "-f", str(preset_path)],
            capture_output=True, text=True
        )
        assert result.returncode == 0

        docs = list(yaml.safe_load_all(result.stdout))
        pod_specs = []

        for doc in docs:
            if not doc:
                continue
            kind = doc.get("kind", "")
            if kind in ["Deployment", "StatefulSet", "DaemonSet", "Job", "Pod"]:
                template = doc.get("spec", {}).get("template", {})
                spec = template.get("spec", {})
                pod_specs.append({
                    "kind": kind,
                    "name": doc.get("metadata", {}).get("name", "unknown"),
                    "spec": spec
                })

        return pod_specs

    def test_drop_capabilities_are_set(self, chart_path, preset_path):
        """Test that drop capabilities are set"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                capabilities = sec_ctx.get("capabilities", {})

                drop = capabilities.get("drop", [])
                # At least some capabilities should be dropped for security
                if drop:
                    assert isinstance(drop, list), "drop capabilities should be a list"
                    assert "ALL" not in drop, "drop: ALL is too aggressive (breaks containers)"

    def test_cap_net_raw_is_dropped(self, chart_path, preset_path):
        """Test that CAP_NET_RAW is dropped (no raw sockets)"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                capabilities = sec_ctx.get("capabilities", {})

                drop = capabilities.get("drop", [])
                add = capabilities.get("add", [])

                # CAP_NET_RAW should not be added
                assert "NET_RAW" not in add, \
                    f"Container {container_name} should not add CAP_NET_RAW"

                # If drop is specified, NET_RAW should be in it
                if drop:
                    # This is ideal but not always possible
                    if "NET_RAW" in drop:
                        pass  # Good - NET_RAW is dropped

    def test_no_wildcard_capabilities_added(self, chart_path, preset_path):
        """Test that no wildcard capabilities ('ALL') are added"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                capabilities = sec_ctx.get("capabilities", {})

                add = capabilities.get("add", [])
                assert "ALL" not in add, \
                    f"Container {container_name} should not add ALL capabilities"

    def test_add_capabilities_are_minimal(self, chart_path, preset_path):
        """Test that add capabilities are minimal (only if required)"""
        pod_specs = self._get_pod_specs(chart_path, preset_path)

        for pod_spec in pod_specs:
            containers = pod_spec["spec"].get("containers", [])
            for container in containers:
                container_name = container.get("name", "unknown")
                sec_ctx = container.get("securityContext", {})
                capabilities = sec_ctx.get("capabilities", {})

                add = capabilities.get("add", [])
                # Added capabilities should be minimal
                # Common safe capabilities: CHOWN, DAC_OVERRIDE, FOWNER, SETGID, SETUID
                safe_capabilities = {"CHOWN", "DAC_OVERRIDE", "FOWNER", "SETGID", "SETUID"}
                unsafe_capabilities = set(add) - safe_capabilities

                if unsafe_capabilities:
                    pytest.skip(f"Container {container_name} adds potentially unsafe capabilities: {unsafe_capabilities}")
```

### Expected Outcome

4 new test files in tests/security/container/:
- test_container_non_root.py (~200 LOC)
- test_container_no_privilege.py (~150 LOC)
- test_container_readonly_fs.py (~150 LOC)
- test_container_capabilities.py (~200 LOC)

### Scope Estimate

- Files: 4
- Lines: ~700 (MEDIUM)
- Tokens: ~6000

### Completion Criteria

```bash
# Run all container security tests
pytest tests/security/container/ -v

# Coverage check
pytest tests/security/container/ --cov=tests/security/container --cov-report=term-missing --cov-fail-under=80

# Specific test
pytest tests/security/container/test_container_non_root.py::TestContainerNonRoot::test_pod_run_as_user_is_not_root -v
```

### Constraints

- DO NOT require actual Kubernetes cluster (use helm template only)
- DO NOT fail if security context is not configured (skip gracefully)
- DO NOT assume default UID (test with different values)
- MUST validate both Spark 3.5 and 4.1 charts

---

## Execution Report

**Executed by:** ______
**Date:** ______
**Duration:** ______ minutes

### Goal Status
- [ ] AC1-AC8 â€” âœ…

**Goal Achieved:** ______

### Files Changed
| File | Action | LOC |
|------|--------|-----|
|      |        |     |

### Statistics
- **Files Changed:** ______
- **Lines Added:** ______
- **Lines Removed:** ______
- **Test Coverage:** ______ %
- **Tests Passed:** ______
- **Tests Failed:** ______

### Deviations from Plan
- ______

### Commit
______

---

### Review Result

**Reviewed by:** Cursor Composer
**Date:** 2026-02-10

#### ðŸŽ¯ Goal Status

- [x] AC1: 4 test files in tests/security/container/ â€” âœ…
- [x] AC2: test_container_non_root.py validates non-root user â€” âœ…
- [x] AC3: test_container_no_privilege.py validates privilege escalation disabled â€” âœ…
- [x] AC4: test_container_readonly_fs.py validates read-only root filesystem â€” âœ…
- [x] AC5: test_container_capabilities.py validates dropped capabilities â€” âœ…
- [x] AC6: All tests validate Spark 3.5 and 4.1 â€” âœ…
- [x] AC7: Coverage >= 80% (84â€“94%) â€” âœ…
- [x] AC8: All tests pass â€” âœ…

**Goal Achieved:** âœ… YES

#### Metrics Summary

| Check | Status |
|-------|--------|
| Completion Criteria | âœ… |
| Tests & Coverage | âœ… 84â€“94% |
| AI-Readiness | âœ… max 153 LOC |
| Type Hints | âœ… |
| Error Handling | âœ… |
