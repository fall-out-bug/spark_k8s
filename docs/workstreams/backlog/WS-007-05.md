# WS-007-05: Security Stability Tests

## Goal
Создать 4 security stability load тестов для проверки стабильности security настроек при sustained load (30 минут).

### Acceptance Criteria
1. 4 security stability load тестов созданы в `tests/load/phase07/test_07_05_security_stability.py`
2. Sustained load duration: 30 минут
3. Security settings проверены при нагрузке (PSS, SCC, RBAC)
4. Load profile: sustained queries with security constraints
5. Security метрики собираются (authorization rate, policy violations)
6. Stability проверяется (no security failures over 30 min)

## Context

**Существующая инфраструктура:**
- `tests/load/phase07/test_07_01_baseline_load.py` — baseline load тесты
- `tests/security/phase08/test_08_01_pss.py` — PSS тесты (будут созданы в Phase 8)

**Что нужно добавить:**
- Security-specific load testing
- Sustained load with PSS/SCC/RBAC enabled
- Authorization rate metrics
- Policy violation tracking
- Отдельный файл `tests/load/phase07/test_07_05_security_stability.py`

## Dependency
Phase 0 (Helm Charts), Phase 1 (Critical Security), Phase 8 (Advanced Security)

## Input Files
- `tests/load/phase07/conftest.py` (shared fixtures)
- `tests/load/phase07/test_07_01_baseline_load.py` (reference)
- `charts/spark-3.5/values.yaml`
- `charts/spark-4.1/values.yaml`

## Steps

### 1. Create test_07_05_security_stability.py
- Создать `tests/load/phase07/test_07_05_security_stability.py`
- Implement 4 test scenarios

### 2. Implement test scenarios

**Security Stability Scenarios:**

1. **PSS Restricted — Sustained load (30 min)**
   - Run queries with PSS restricted profile
   - Validate: no PSS violations over 30 min
   - Metrics: PSS compliance rate

2. **SCC Restricted — Sustained load (30 min)**
   - Run queries with SCC restricted (mocked)
   - Validate: no SCC violations over 30 min
   - Metrics: SCC compliance rate

3. **RBAC Least Privilege — Sustained load (30 min)**
   - Run queries with minimal permissions
   - Validate: no authorization errors
   - Metrics: auth success rate

4. **Network Policies — Sustained load (30 min)**
   - Run queries with network policies enabled
   - Validate: no policy violations
   - Metrics: network policy compliance rate

### 3. Security Metrics Collection
- security_compliance_rate: percentage of compliant operations
- authorization_success_rate: successful auth operations / total
- policy_violations: number of policy violations
- security_overhead: performance impact of security
- pss_violations: PSS-specific violations
- rbac_denials: RBAC access denied events

### 4. Run tests
- `pytest tests/load/phase07/test_07_05_security_stability.py -v --timeout=2400`

## Code

### tests/load/phase07/test_07_05_security_stability.py

```python
"""Security Stability Load Tests for Phase 7

Load tests for security settings stability under sustained load.
"""

import pytest
import time
import subprocess
from pyspark.sql import SparkSession

class TestSecurityStability:
    """Security stability load tests"""

    @pytest.mark.timeout(2400)
    @pytest.mark.load
    @pytest.mark.security
    def test_01_pss_restricted_sustained_load(self, spark_load_session, nyc_taxi_dataset_path, load_metrics, load_duration_seconds):
        """PSS Restricted — Sustained load (30 min)"""
        # Enable PSS restricted
        # This is typically set at namespace level, not in Spark config
        # We simulate by checking compliance

        df = spark_load_session.read.parquet(str(nyc_taxi_dataset_path))
        df = df.sample(0.01)
        df.createOrReplaceTempView("nyc_taxi")

        start_time = time.time()
        end_time = start_time + load_duration_seconds

        query_count = 0
        pss_compliant_count = 0
        pss_violation_count = 0

        while time.time() < end_time:
            try:
                result = spark_load_session.sql("SELECT COUNT(*) FROM nyc_taxi")
                result.collect()

                # Simulate PSS compliance check
                # In real scenario, this would validate against PSS profile
                is_compliant = True  # Assume compliant if no error
                if is_compliant:
                    pss_compliant_count += 1
                else:
                    pss_violation_count += 1

                query_count += 1
                load_metrics("test_pss_01_queries", query_count)
                time.sleep(1)

            except Exception as e:
                error_msg = str(e).lower()
                if 'pod security' in error_msg or 'privileged' in error_msg:
                    pss_violation_count += 1
                load_metrics("test_pss_01_error", str(e))

        compliance_rate = pss_compliant_count / query_count if query_count > 0 else 0

        assert query_count > 1500
        assert pss_violation_count == 0, f"Should have no PSS violations, got {pss_violation_count}"

        load_metrics("test_pss_01_total_queries", query_count)
        load_metrics("test_pss_01_compliance_rate", compliance_rate)

    @pytest.mark.timeout(2400)
    @pytest.mark.load
    @pytest.mark.security
    def test_02_scc_restricted_sustained_load(self, spark_load_session, nyc_taxi_dataset_path, load_metrics, load_duration_seconds):
        """SCC Restricted — Sustained load (30 min)"""
        # Mock SCC checks (no real OpenShift cluster)
        df = spark_load_session.read.parquet(str(nyc_taxi_dataset_path))
        df = df.sample(0.01)
        df.createOrReplaceTempView("nyc_taxi")

        start_time = time.time()
        end_time = start_time + load_duration_seconds

        query_count = 0
        scc_compliant_count = 0
        scc_violation_count = 0

        while time.time() < end_time:
            try:
                result = spark_load_session.sql("""
                    SELECT passenger_count, COUNT(*) FROM nyc_taxi GROUP BY passenger_count
                """)
                result.collect()

                # Simulate SCC compliance check
                # Check runAsUser, runAsGroup, fsGroup
                is_compliant = True  # Assume compliant
                if is_compliant:
                    scc_compliant_count += 1
                else:
                    scc_violation_count += 1

                query_count += 1
                load_metrics("test_scc_02_queries", query_count)
                time.sleep(1)

            except Exception as e:
                scc_violation_count += 1
                load_metrics("test_scc_02_error", str(e))

        compliance_rate = scc_compliant_count / query_count if query_count > 0 else 0

        assert query_count > 1500
        assert scc_violation_count < 10, f"SCC violations should be minimal, got {scc_violation_count}"

        load_metrics("test_scc_02_total_queries", query_count)
        load_metrics("test_scc_02_compliance_rate", compliance_rate)

    @pytest.mark.timeout(2400)
    @pytest.mark.load
    @pytest.mark.security
    def test_03_rbac_least_privilege_sustained_load(self, spark_load_session, nyc_taxi_dataset_path, load_metrics, load_duration_seconds):
        """RBAC Least Privilege — Sustained load (30 min)"""
        # Simulate RBAC checks
        df = spark_load_session.read.parquet(str(nyc_taxi_dataset_path))
        df = df.sample(0.01)
        df.createOrReplaceTempView("nyc_taxi")

        start_time = time.time()
        end_time = start_time + load_duration_seconds

        query_count = 0
        auth_success_count = 0
        auth_denied_count = 0

        while time.time() < end_time:
            try:
                # Simulate RBAC authorization check
                # In real scenario, this would check permissions
                has_permission = True  # Assume least privilege allows

                if has_permission:
                    result = spark_load_session.sql("SELECT COUNT(*) FROM nyc_taxi")
                    result.collect()
                    auth_success_count += 1
                else:
                    auth_denied_count += 1

                query_count += 1
                load_metrics("test_rbac_03_queries", query_count)
                time.sleep(1)

            except Exception as e:
                error_msg = str(e).lower()
                if 'permission denied' in error_msg or 'unauthorized' in error_msg:
                    auth_denied_count += 1
                load_metrics("test_rbac_03_error", str(e))

        auth_rate = auth_success_count / query_count if query_count > 0 else 0

        assert query_count > 1500
        assert auth_denied_count == 0, f"Should have no auth denials, got {auth_denied_count}"

        load_metrics("test_rbac_03_total_queries", query_count)
        load_metrics("test_rbac_03_auth_success_rate", auth_rate)

    @pytest.mark.timeout(2400)
    @pytest.mark.load
    @pytest.mark.security
    def test_04_network_policies_sustained_load(self, spark_load_session, nyc_taxi_dataset_path, load_metrics, load_duration_seconds):
        """Network Policies — Sustained load (30 min)"""
        # Simulate network policy compliance
        df = spark_load_session.read.parquet(str(nyc_taxi_dataset_path))
        df = df.sample(0.01)
        df.createOrReplaceTempView("nyc_taxi")

        start_time = time.time()
        end_time = start_time + load_duration_seconds

        query_count = 0
        policy_compliant_count = 0
        policy_violation_count = 0

        while time.time() < end_time:
            try:
                result = spark_load_session.sql("""
                    SELECT passenger_count, AVG(total_amount) FROM nyc_taxi GROUP BY passenger_count
                """)
                result.collect()

                # Simulate network policy check
                # In real scenario, this validates traffic against policies
                is_allowed = True  # Assume allowed by policy

                if is_allowed:
                    policy_compliant_count += 1
                else:
                    policy_violation_count += 1

                query_count += 1
                load_metrics("test_np_04_queries", query_count)
                time.sleep(1)

            except Exception as e:
                error_msg = str(e).lower()
                if 'network' in error_msg or 'connection' in error_msg:
                    policy_violation_count += 1
                load_metrics("test_np_04_error", str(e))

        compliance_rate = policy_compliant_count / query_count if query_count > 0 else 0

        assert query_count > 1500
        assert policy_violation_count == 0, f"Should have no policy violations, got {policy_violation_count}"

        load_metrics("test_np_04_total_queries", query_count)
        load_metrics("test_np_04_compliance_rate", compliance_rate)
```

## Scope Estimate
- Files: 1 (test_07_05_security_stability.py)
- LOC: ~600 (tests + security logic)
- Scenarios: 4
- Duration: 30 min × 4 = 2 hours execution time
- Size: MEDIUM
