---
ws_id: 00-017-01
feature: F17
status: backlog
size: MEDIUM
project_id: 00
github_issue: null
assignee: null
depends_on:
  - 00-006-01  # Helm charts
  - 00-011-01  # Spark 3.5 images
  - 00-011-02  # Spark 4.1 images
---

## WS-00-017-01: Spark Connect Go client library

### üéØ Goal

**What must WORK after completing this WS:**
- Spark Connect Go client library
- gRPC integration with Spark Connect server
- SQL execution
- DataFrame operations
- Session management

**Acceptance Criteria:**
- [ ] AC1: Go client library —Å–æ–∑–¥–∞–Ω
- [ ] AC2: gRPC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Spark Connect —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] AC3: SQL query execution —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] AC4: DataFrame collect —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] AC5: Session management —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] AC6: Error handling —Ä–∞–±–æ—Ç–∞–µ—Ç

**‚ö†Ô∏è WS is NOT complete until Goal is achieved (all AC ‚úÖ).**

---

### Dependencies

Phase 0 (F06), Phase 5 (F11)

### Code

```go
// tests/go/client/connect.go
package spark

import (
	"context"
	"crypto/tls"
	"fmt"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	connect "github.com/apache/spark/connect/go/v1/client"
)

// Client represents a Spark Connect client
type Client struct {
	conn      *grpc.ClientConn
	client    *connect.SparkConnectServiceClient
	sessionID string
	timeout   time.Duration
}

// ClientOption configures a Spark Connect client
type ClientOption func(*Client)

// WithTimeout sets the request timeout
func WithTimeout(timeout time.Duration) ClientOption {
	return func(c *Client) {
		c.timeout = timeout
	}
}

// WithTLS enables TLS connection
func WithTLS(config *tls.Config) ClientOption {
	return func(c *Client) {
		// Configure TLS credentials
	}
}

// NewClient creates a new Spark Connect client
func NewClient(ctx context.Context, endpoint string, opts ...ClientOption) (*Client, error) {
	client := &Client{
		timeout: 30 * time.Second,
	}

	// Apply options
	for _, opt := range opts {
		opt(client)
	}

	// Create gRPC connection
	creds := credentials.NewTLS(&tls.Config{
		InsecureSkipVerify: true, // For development
	})

	conn, err := grpc.DialContext(ctx, endpoint,
		grpc.WithTransportCredentials(creds),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Spark Connect: %w", err)
	}

	client.conn = conn
	client.client = connect.NewSparkConnectServiceClient(conn)

	return client, nil
}

// Close closes the client connection
func (c *Client) Close() error {
	return c.conn.Close()
}

// Session represents a Spark session
type Session struct {
	client    *Client
	sessionID string
	config    map[string]string
}

// CreateSession creates a new Spark session
func (c *Client) CreateSession(ctx context.Context) (*Session, error) {
	req := &connect.CreateSessionRequest{
		UserContext: &connect.UserContext{
			UserId:    "go-client",
			UserName:  "go-user",
			AppName:   "Spark Connect Go",
			Deployment: "k8s",
		},
	}

	resp, err := c.client.CreateServerSideSession(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	session := &Session{
		client:    c,
		sessionID: resp.SessionId,
		config:    make(map[string]string),
	}

	return session, nil
}

// ID returns the session ID
func (s *Session) ID() string {
	return s.sessionID
}

// Close closes the session
func (s *Session) Close(ctx context.Context) error {
	_, err := s.client.client.CloseSession(ctx, &connect.CloseSessionRequest{
		SessionId: s.sessionID,
	})
	return err
}

// DataFrame represents a Spark DataFrame
type DataFrame struct {
	session *Session
	plan    *connect.Plan
}

// SQL executes a SQL query and returns a DataFrame
func (s *Session) SQL(ctx context.Context, query string) (*DataFrame, error) {
	plan := &connect.Plan{
		Op: &connect.Plan_Sql{
			Sql: &connect.SQL{
				Query: query,
			},
		},
	}

	return &DataFrame{
		session: s,
		plan:    plan,
	}, nil
}

// Collect collects all rows from the DataFrame
func (df *DataFrame) Collect(ctx context.Context) ([]Row, error) {
	req := &connect.ExecutePlanRequest{
		SessionId: df.session.sessionID,
		Plan:      df.plan,
	}

	resp, err := df.session.client.client.ExecutePlan(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute plan: %w", err)
	}

	// Parse response into rows
	rows := make([]Row, 0)
	for _, batch := range resp.OutputBatches {
		for _, row := range batch.GetData().GetRows() {
			rows = append(rows, Row{values: row.Values})
		}
	}

	return rows, nil
}

// Show prints the first 20 rows
func (df *DataFrame) Show(ctx context.Context) error {
	rows, err := df.Collect(ctx)
	if err != nil {
		return err
	}

	limit := 20
	if len(rows) < limit {
		limit = len(rows)
	}

	for i := 0; i < limit; i++ {
		fmt.Println(rows[i])
	}

	return nil
}

// Count returns the number of rows
func (df *DataFrame) Count(ctx context.Context) (int64, error) {
	req := &connect.ExecutePlanRequest{
		SessionId: df.session.sessionID,
		Plan:      df.plan,
	}

	resp, err := df.session.client.client.ExecutePlan(ctx, req)
	if err != nil {
		return 0, err
	}

	// Parse count from response
	return int64(len(resp.OutputBatches)), nil
}

// Row represents a single row
type Row struct {
	values []*connect.Expression_Literal
}

// String returns a string representation of the row
func (r *Row) String() string {
	values := make([]interface{}, len(r.values))
	for i, v := range r.values {
		values[i] = v.GetValue()
	}
	return fmt.Sprint(values)
}

// GetInt gets an int value at index
func (r *Row) GetInt(i int) (int32, error) {
	if i >= len(r.values) {
		return 0, fmt.Errorf("index out of bounds")
	}
	return r.values[i].GetInt(), nil
}

// GetString gets a string value at index
func (r *Row) GetString(i int) (string, error) {
	if i >= len(r.values) {
		return "", fmt.Errorf("index out of bounds")
	}
	return r.values[i].GetString(), nil
}

// GetFloat gets a float value at index
func (r *Row) GetFloat(i int) (float64, error) {
	if i >= len(r.values) {
		return 0, fmt.Errorf("index out of bounds")
	}
	return r.values[i].GetFloat(), nil
}
```

### Scope Estimate

- Files: 8
- Lines: ~800 (MEDIUM)
- Tokens: ~6000

### Constraints

- DO use official Spark Connect gRPC protocol
- DO support Spark 3.5+ and 4.1+
- DO use TLS for production connections
- DO handle connection errors gracefully
- DO NOT support Spark < 3.5 (no Connect)

---

## Execution Report

**Executed by:** ______
**Date:** ______
**Duration:** ______ minutes

### Goal Status
- [ ] AC1-AC6 ‚Äî ‚úÖ

**Goal Achieved:** ______
