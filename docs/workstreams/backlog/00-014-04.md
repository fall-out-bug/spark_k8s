---
ws_id: 00-014-04
feature: F14
status: backlog
size: MEDIUM
project_id: 00
github_issue: null
assignee: null
depends_on:
  - 00-006-01  # Helm charts
  - 00-007-01  # Security templates
---

## WS-00-014-04: RBAC tests (6 scenarios)

### ðŸŽ¯ Goal

**What must WORK after completing this WS:**
- 6 RBAC test scenarios
- ServiceAccount permissions validation
- Role/ClusterRole least privilege checks
- No wildcard permissions

**Acceptance Criteria:**
- [ ] AC1: 6 RBAC test scenarios created
- [ ] AC2: ServiceAccount permissions validated
- [ ] AC3: Role/ClusterRole follow least privilege
- [ ] AC4: No wildcard permissions in rules
- [ ] AC5: Resource-specific rules only
- [ ] AC6: Verb-specific rules only

**âš ï¸ WS is NOT complete until Goal is achieved (all AC âœ…).**

---

### Scenarios

| Scenario | Resource | Verbs | Scope | Check |
|----------|----------|-------|-------|-------|
| 1 | ServiceAccount | create, get | pod | Least privilege |
| 2 | ServiceAccount | create, get | configmap | Least privilege |
| 3 | Role | get, list, watch | pods, services | Namespace-scoped |
| 4 | Role | create, delete | jobs | Namespace-scoped |
| 5 | ClusterRole | get, list | nodes | Cluster-wide (minimal) |
| 6 | ClusterRole | create | persistentvolumes | Cluster-wide (minimal) |

### Dependencies

- WS-006-01 (Helm charts)
- WS-007-01 (Security templates)

### Code

```python
# tests/security/rbac/test_rbac_service_accounts.py
import pytest
import yaml

def test_rbac_service_account_least_privilege(helm_chart_path):
    """
    Validate ServiceAccount has least privilege permissions
    """
    cmd = [
        "helm", "template", "spark-3.5",
        helm_chart_path,
        "--set", "rbac.create=true"
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    assert result.returncode == 0

    docs = list(yaml.safe_load_all(result.stdout))

    # Find ServiceAccounts
    service_accounts = [doc for doc in docs if doc.get("kind") == "ServiceAccount"]
    assert len(service_accounts) > 0, "No ServiceAccounts found"

    # Find Roles/ClusterRoles
    roles = [doc for doc in docs if doc.get("kind") == "Role"]
    cluster_roles = [doc for doc in docs if doc.get("kind") == "ClusterRole"]

    # Check RoleBindings for ServiceAccount associations
    role_bindings = [doc for doc in docs if doc.get("kind") == "RoleBinding"]
    cluster_role_bindings = [doc for doc in docs if doc.get("kind") == "ClusterRoleBinding"]

    # Validate least privilege
    for role in roles + cluster_roles:
        role_name = role["metadata"]["name"]

        for rule in role.get("rules", []):
            resources = rule.get("resources", [])
            verbs = rule.get("verbs", [])

            # Check for wildcard resources
            assert "*" not in resources, f"{role_name}: wildcard resources not allowed"
            assert "*" not in verbs, f"{role_name}: wildcard verbs not allowed"

            # Check for overly broad resource lists
            assert len(resources) < 10, f"{role_name}: too many resources ({len(resources)})"

            # Check for overly broad verbs
            assert len(verbs) < 6, f"{role_name}: too many verbs ({len(verbs)})"

            # Specific checks for common patterns
            if "pods" in resources:
                # Pods should only need get, list, watch for most cases
                allowed_pod_verbs = ["get", "list", "watch", "create", "delete"]
                for verb in verbs:
                    assert verb in allowed_pod_verbs, \
                        f"{role_name}: unexpected verb '{verb}' for pods resource"

def test_rbac_no_wildcard_permissions(helm_chart_path):
    """
    Validate no wildcard permissions in RBAC rules
    """
    cmd = [
        "helm", "template", "spark-3.5",
        helm_chart_path,
        "--set", "rbac.create=true"
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    assert result.returncode == 0

    docs = list(yaml.safe_load_all(result.stdout))

    roles = [doc for doc in docs if doc.get("kind") in ["Role", "ClusterRole"]]

    for role in roles:
        role_name = role["metadata"]["name"]

        for rule in role.get("rules", []):
            resources = rule.get("resources", [])
            verbs = rule.get("verbs", [])
            api_groups = rule.get("apiGroups", [])

            # No wildcards
            assert "*" not in resources, \
                f"{role_name}: wildcard resources forbidden: {resources}"

            assert "*" not in verbs, \
                f"{role_name}: wildcard verbs forbidden: {verbs}"

            # apiGroups ["*"] is sometimes necessary but should be minimal
            if "*" in api_groups:
                # Only allow if resources are very specific
                assert len(resources) <= 2, \
                    f"{role_name}: wildcard apiGroups with many resources: {resources}"

def test_rbac_resource_specific_rules(helm_chart_path):
    """
    Validate all rules are resource-specific
    """
    cmd = [
        "helm", "template", "spark-3.5",
        helm_chart_path,
        "--set", "rbac.create=true"
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    assert result.returncode == 0

    docs = list(yaml.safe_load_all(result.stdout))

    roles = [doc for doc in docs if doc.get("kind") in ["Role", "ClusterRole"]]

    for role in roles:
        role_name = role["metadata"]["name"]

        for rule in role.get("rules", []):
            resources = rule.get("resources", [])
            resource_names = rule.get("resourceNames", [])

            # If resourceNames is specified, resources must be single-item
            if resource_names:
                assert len(resources) == 1, \
                    f"{role_name}: resourceNames requires single resource type"

def test_rbac_namespace_scoped_where_possible(helm_chart_path):
    """
    Validate Role (namespace-scoped) is used where possible
    instead of ClusterRole (cluster-wide)
    """
    cmd = [
        "helm", "template", "spark-3.5",
        helm_chart_path,
        "--set", "rbac.create=true"
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    assert result.returncode == 0

    docs = list(yaml.safe_load_all(result.stdout))

    roles = [doc for doc in docs if doc.get("kind") == "Role"]
    cluster_roles = [doc for doc in docs if doc.get("kind") == "ClusterRole"]

    # ClusterRoles should be minimal
    cluster_role_names = [cr["metadata"]["name"] for cr in cluster_roles]

    # Most permissions should be namespace-scoped (Role)
    assert len(roles) >= len(cluster_roles), \
        f"Prefer namespace-scoped Roles: {len(roles)} Roles vs {len(cluster_roles)} ClusterRoles"

    # ClusterRoles should only be for cluster-wide resources
    for cr in cluster_roles:
        cr_name = cr["metadata"]["name"]

        for rule in cr.get("rules", []):
            resources = rule.get("resources", [])

            # Cluster-wide resources that legitimately need ClusterRole
            cluster_wide_resources = [
                "nodes", "persistentvolumes", "storageclasses",
                "clusterroles", "clusterrolebindings"
            ]

            # If no cluster-wide resources, this should be a Role instead
            has_cluster_wide = any(r in cluster_wide_resources for r in resources)

            assert has_cluster_wide, \
                f"{cr_name}: ClusterRole used without cluster-wide resources: {resources}"
```

### Scope Estimate

- Files: 6
- Lines: ~500 (MEDIUM)
- Tokens: ~4000

### Constraints

- DO enforce least privilege principle
- DO check for wildcard permissions
- DO prefer Role over ClusterRole where possible
- DO NOT allow wildcard resources/verbs

---

## Execution Report

**Executed by:** ______
**Date:** ______
**Duration:** ______ minutes

### Goal Status
- [ ] AC1-AC6 â€” âœ…

**Goal Achieved:** ______
