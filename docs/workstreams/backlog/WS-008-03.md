# WS-008-03: Network Policies Tests

## Goal
Создать 6 тестов для проверки Kubernetes Network Policies для всех компонентов Spark.

### Acceptance Criteria
1. 6 network policy тестов созданы в `tests/security/phase08/test_08_03_network_policies.py`
2. Default-deny policy проверен — блокирует весь ingress/egress
3. Spark-connect ingress проверен — разрешает порт 15002
4. DNS egress проверен — разрешает UDP:53
5. S3 egress проверен — разрешает TCP:9000
6. Cross-namespace проверен — блокирует несанкционированный ns доступ
7. Worker communication проверен — разрешает spark-connect ↔ worker
8. Все тесты используют `helm template` для рендеринга

## Context

**Существующая инфраструктура:**
- `charts/spark-3.5/templates/networking/network-policy.yaml` — network policies
- Default-deny policy для всех namespace
- Explicit allow rules для spark-connect, jupyter, S3, PostgreSQL, Hive Metastore
- Существующие тесты в `tests/security/test_security.py` (NetworkPolicies: template exists, default-deny, explicit allow rules)

**Что нужно добавить:**
- Структурированные network policy тесты
- Проверка всех типов трафика (ingress/egress)
- Проверка cross-namespace коммуникации
- Отдельный файл `tests/security/phase08/test_08_03_network_policies.py`

## Dependency
Phase 0 (Helm Charts), Phase 1 (Critical Security)

## Input Files
- `charts/spark-3.5/templates/networking/network-policy.yaml`
- `charts/spark-3.5/values.yaml`
- `charts/spark-3.5/templates/spark-connect.yaml`
- `charts/spark-3.5/templates/spark-standalone-worker.yaml`
- `tests/security/test_security.py` (reference)

## Steps

### 1. Create test_08_03_network_policies.py
- Создать `tests/security/phase08/test_08_03_network_policies.py`
- Implement 6 test scenarios

### 2. Implement test scenarios

**Scenario 1: Default-deny — blocks all ingress/egress**
- Render template с network policies
- Проверить наличие NetworkPolicy с name: default-deny
- Проверить podSelector: {} (все pods)
- Проверить отсутствие ingress rules (или пустой список)
- Проверить отсутствие egress rules (или пустой список)

**Scenario 2: Spark-connect ingress — allows port 15002**
- Render template с sparkConnect.enabled=true
- Проверить NetworkPolicy для spark-connect
- Проверить port: 15002 (spark-connect default port)
- Проверить protocol: TCP
- Проверить from: [<allowed sources>]

**Scenario 3: DNS egress — allows UDP:53**
- Render template с network policies
- Проверить NetworkPolicy для DNS
- Проверить port: 53
- Проверить protocol: UDP
- Проверить to: [<kube-dns>]

**Scenario 4: S3 egress — allows TCP:9000**
- Render template с S3 storage
- Проверить NetworkPolicy для S3/MinIO
- Проверить port: 9000 (MinIO default)
- Проверить protocol: TCP
- Проверить to: [<minio service>]

**Scenario 5: Cross-namespace — blocks unauthorized ns access**
- Render template с multiple namespaces
- Проверить namespace selectors в NetworkPolicy
- Проверить что только разрешенные namespace доступны
- Проверить блокировку меж-namespace трафика по умолчанию

**Scenario 6: Worker communication — allows spark-connect ↔ worker**
- Render template с sparkStandalone.enabled=true
- Проверить NetworkPolicy для spark-connect ↔ worker
- Проверить port range для spark communication (по умолчанию 1024-65535)
- Проверить podSelector для worker pods
- Проверить双向 communication (ingress + egress)

### 3. Run tests
- `pytest tests/security/phase08/test_08_03_network_policies.py -v`
- Убедиться что все 6 тестов проходят

## Code

### tests/security/phase08/test_08_03_network_policies.py

```python
"""Network Policies Tests for Phase 8

Tests for Kubernetes Network Policies across all Spark components.
"""

import pytest
import subprocess
import tempfile
import yaml
from pathlib import Path
from typing import Dict, List, Any


class TestNetworkPolicies:
    """Network Policies compliance tests"""

    @pytest.fixture
    def rendered_template(self, spark_35_chart):
        """Render helm template with network policies enabled"""
        with tempfile.NamedTemporaryFile(mode="w+", suffix=".yaml") as f:
            result = subprocess.run(
                ["helm", "template", "spark-test", str(spark_35_chart),
                 "--set", "sparkConnect.enabled=true",
                 "--set", "sparkStandalone.enabled=true",
                 "--set", "networkPolicies.enabled=true"],
                capture_output=True, text=True
            )
            f.write(result.stdout)
            f.flush()
            return result.stdout

    @pytest.fixture
    def network_policies(self, rendered_template):
        """Parse NetworkPolicy resources from rendered template"""
        documents = list(yaml.safe_load_all(rendered_template))
        return [doc for doc in documents if doc and doc.get('kind') == 'NetworkPolicy']

    def test_01_default_deny_blocks_all_traffic(self, network_policies):
        """Default-deny — blocks all ingress/egress"""
        # Find default-deny policy
        default_deny = None
        for policy in network_policies:
            metadata = policy.get('metadata', {})
            if 'default-deny' in metadata.get('name', '').lower():
                default_deny = policy
                break

        assert default_deny is not None, "Default-deny NetworkPolicy not found"

        spec = default_deny.get('spec', {})
        pod_selector = spec.get('podSelector', {})

        # Should apply to all pods (empty selector)
        assert pod_selector == {}, f"Default-deny should apply to all pods, got: {pod_selector}"

        # Should block all traffic (empty rules)
        ingress = spec.get('ingress')
        egress = spec.get('egress')

        # Empty or missing means deny all
        assert ingress is None or ingress == [], "Default-deny should block all ingress"
        assert egress is None or egress == [], "Default-deny should block all egress"

    def test_02_spark_connect_ingress_port_15002(self, network_policies):
        """Spark-connect ingress — allows port 15002"""
        # Find spark-connect policy
        spark_connect_policy = None
        for policy in network_policies:
            metadata = policy.get('metadata', {})
            if 'spark-connect' in metadata.get('name', '').lower():
                spark_connect_policy = policy
                break

        # If no specific policy, check if default-deny allows spark-connect
        if not spark_connect_policy:
            # Check if there's a policy with ingress rules for port 15002
            for policy in network_policies:
                ingress = policy.get('spec', {}).get('ingress', [])
                for rule in ingress:
                    ports = rule.get('ports', [])
                    for port in ports:
                        if port.get('port') == 15002:
                            spark_connect_policy = policy
                            break
                    if spark_connect_policy:
                        break
                if spark_connect_policy:
                    break

        assert spark_connect_policy is not None, "Spark-connect NetworkPolicy not found"

        spec = spark_connect_policy.get('spec', {})
        ingress = spec.get('ingress', [])

        # Check for port 15002 allowance
        found_port = False
        for rule in ingress:
            ports = rule.get('ports', [])
            for port in ports:
                if port.get('port') in [15002, '15002']:
                    found_port = True
                    assert port.get('protocol') in ['TCP', 'tcp'], "Port 15002 should be TCP"
                    break

        assert found_port, "Port 15002 not allowed in ingress rules"

    def test_03_dns_egress_udp_53(self, network_policies):
        """DNS egress — allows UDP:53"""
        # Check for DNS policy
        dns_policy = None
        for policy in network_policies:
            metadata = policy.get('metadata', {})
            if 'dns' in metadata.get('name', '').lower():
                dns_policy = policy
                break

        # If no specific DNS policy, check all policies for DNS allowance
        found_dns = False
        for policy in network_policies:
            egress = policy.get('spec', {}).get('egress', [])
            for rule in egress:
                ports = rule.get('ports', [])
                for port in ports:
                    if port.get('port') in [53, '53']:
                        found_dns = True
                        assert port.get('protocol') in ['UDP', 'udp'], "DNS port 53 should be UDP"
                        break
                if found_dns:
                    break

                # Also check to: for kube-dns
                to = rule.get('to', [])
                for to_item in to:
                    namespace_selector = to_item.get('namespaceSelector', {})
                    match_labels = namespace_selector.get('matchLabels', {})
                    if 'kube-system' in match_labels.values() or 'dns' in str(match_labels).lower():
                        found_dns = True
                        break

        assert found_dns, "DNS egress (UDP:53) not found in network policies"

    def test_04_s3_egress_tcp_9000(self, network_policies):
        """S3 egress — allows TCP:9000"""
        # Check for S3/MinIO policy
        found_s3 = False
        for policy in network_policies:
            metadata = policy.get('metadata', {})
            if 's3' in metadata.get('name', '').lower() or 'minio' in metadata.get('name', '').lower():
                found_s3 = True
                spec = policy.get('spec', {})
                egress = spec.get('egress', [])
                # Check for port 9000
                for rule in egress:
                    ports = rule.get('ports', [])
                    for port in ports:
                        if port.get('port') in [9000, '9000']:
                            assert port.get('protocol') in ['TCP', 'tcp'], "S3 port 9000 should be TCP"
                            break

        # Also check in general policies for S3 allowance
        if not found_s3:
            for policy in network_policies:
                egress = policy.get('spec', {}).get('egress', [])
                for rule in egress:
                    ports = rule.get('ports', [])
                    for port in ports:
                        if port.get('port') in [9000, '9000']:
                            found_s3 = True
                            assert port.get('protocol') in ['TCP', 'tcp']
                            break

        assert found_s3, "S3 egress (TCP:9000) not found in network policies"

    def test_05_cross_namespace_blocks_unauthorized(self, network_policies):
        """Cross-namespace — blocks unauthorized ns access"""
        # Check that policies have namespace selectors
        has_namespace_selector = False

        for policy in network_policies:
            spec = policy.get('spec', {})

            # Check ingress namespace selectors
            ingress = spec.get('ingress', [])
            for rule in ingress:
                from_items = rule.get('from', [])
                for from_item in from_items:
                    if 'namespaceSelector' in from_item:
                        has_namespace_selector = True
                        # Should only allow specific namespaces
                        selector = from_item.get('namespaceSelector', {})
                        match_labels = selector.get('matchLabels', {})
                        # If empty matchLabels, means all namespaces (bad)
                        # Should have specific labels
                        # This is a soft check - actual enforcement depends on namespace labels

            # Check egress namespace selectors
            egress = spec.get('egress', [])
            for rule in egress:
                to_items = rule.get('to', [])
                for to_item in to_items:
                    if 'namespaceSelector' in to_item:
                        has_namespace_selector = True
                        selector = to_item.get('namespaceSelector', {})

        # If no namespace selector found, that's OK - policies are namespace-scoped by default
        # The important thing is that cross-namespace traffic is blocked by default-deny
        # unless explicitly allowed

        # Verify default-deny exists (blocks all cross-namespace by default)
        default_deny_exists = any(
            'default-deny' in p.get('metadata', {}).get('name', '').lower()
            for p in network_policies
        )
        assert default_deny_exists, "Default-deny policy required for cross-namespace isolation"

    def test_06_worker_communication_allowed(self, network_policies):
        """Worker communication — allows spark-connect ↔ worker"""
        # Check for policies allowing spark-connect ↔ worker communication
        found_worker_policy = False

        for policy in network_policies:
            metadata = policy.get('metadata', {})
            name = metadata.get('name', '').lower()

            if 'worker' in name or 'spark' in name:
                spec = policy.get('spec', {})

                # Check podSelector for worker
                pod_selector = spec.get('podSelector', {})
                if 'worker' in str(pod_selector).lower() or 'spark' in str(pod_selector).lower():
                    found_worker_policy = True

                    # Check ingress rules
                    ingress = spec.get('ingress', [])
                    has_ingress = len(ingress) > 0

                    # Check egress rules
                    egress = spec.get('egress', [])
                    has_egress = len(egress) > 0

                    # Should have either ingress or egress rules
                    assert has_ingress or has_egress, "Worker policy should allow traffic"

                    # Check for port range (Spark uses wide range)
                    for rule in ingress + egress:
                        ports = rule.get('ports', [])
                        for port in ports:
                            port_num = port.get('port')
                            # Spark uses dynamic ports, look for range or specific ports
                            if isinstance(port_num, int) and 1024 <= port_num <= 65535:
                                assert port.get('protocol') in ['TCP', 'tcp', None], "Worker traffic should be TCP"

        if not found_worker_policy:
            # Check if any policy allows high port numbers
            for policy in network_policies:
                spec = policy.get('spec', {})
                for rule in spec.get('ingress', []) + spec.get('egress', []):
                    ports = rule.get('ports', [])
                    for port in ports:
                        port_num = port.get('port')
                        if isinstance(port_num, int):
                            if 1024 <= port_num <= 65535:
                                found_worker_policy = True
                                break
                    if found_worker_policy:
                        break

        assert found_worker_policy, "No policy found for worker communication"

    def test_network_policy_count(self, network_policies):
        """Verify network policies are created"""
        assert len(network_policies) > 0, "No NetworkPolicies found in rendered template"
```

## Scope Estimate
- Files: 1 (test_08_03_network_policies.py)
- LOC: ~500 (tests)
- Scenarios: 6
- Size: MEDIUM
